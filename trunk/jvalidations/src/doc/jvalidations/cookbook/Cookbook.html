<link rel="stylesheet" href="../style.css" type="text/css"><div id='main'><h2>Cookbook</h2><p class='commentary'>This page explains how to do the most common validation tasks and should be read following the tutorial, or for reference. </p><div class='section'>ValidatingValuesReturnedFromMethods</div></pre></p><p class='commentary'>Most places where you use a field name you can also use a method name.  The method must take no arguments and you indicate its a method simply by putting <b>()</b> at the end of it. </p><p><pre class='code'>public class Customer implements Validatable&lt;Customer.ValidationReport&gt; {

    public interface ValidationReport {
        void isNull(String fieldOrMethodName);
    }

    public String someQueryMethod() {
        return null;
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that("someQueryMethod()", isNotNull(), _else(report, "isNull", fieldName()));
    }
}

</pre></p><p class='commentary'>This will call <span class='domaincode'>someQueryMethod()</span> on the instance of <span class='domaincode'>Customer</span> being validated, then validate that the result of that method is not null. </p>
<div class='section'>ValidatingMultipleFields</div></pre></p><p class='commentary'>Its very common to want to say "at least 2 of these 3 fields should be non null": </p><p><pre class='code'>public class Customer implements Validatable&lt;Customer.ValidationReport&gt;{
    private String name;
    private String email;
    private String level;

    public interface ValidationReport {
        void isNull(String []fieldNames, int requiredCount, int ActualCount);
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that(
                atLeast(2).of("name","email","level"),
                isNotNull(),
                _else(report, "isNull", fieldNames(), requiredCount(), actualCount()));
    }
}

</pre></p><p class='commentary'><span class='method'>atLeast()</span> is available as a static method on <span class='class'>SyntaxSupport.Cardinalities</span>, along with other cardinality methods like <span class='method'>exactly()</span>, <span class='method'>all()</span> and <span class='method'>both</span>. <br/> <br/> <span class='method'>fieldNames()</span> is available as a static method on <span class='class'>SyntaxSupport.Parameters</span>.  It will make the list of field names in the validation available as a String array to your callback method.  <span class='method'>requiredCount()</span> and <span class='method'>actualCount()</span> are also on <span class='class'>SyntaxSupport.Parameters</span> and make the number of fields required by the validation cardinality and the actual number of valid fields respectively available to you callback method. </p>
<div class='section'>ValidatingAssociatedObjects</div></pre></p><p class='commentary'>Lets say our <span class='domaincode'>Customer</span> has an <span class='domaincode'>Address</span> object associated with it and when validating the <span class='domaincode'>Customer</span> we want to rope in validation of the <span class='domaincode'>Address</span>.  Well lets walk through that.  The first step is to make the <span class='domaincode'>Address</span> validatable... </p><p><pre class='code'>public class Address implements Validatable&lt;Address.ValidationReport&gt;{
    private String addressLine1;
    private String addressLine2;
    private String city;
    private String postCode;

    public interface ValidationReport {
        void required(String fieldName);
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that("addressLine1", isNotBlank(), _else(report, "required", fieldName()));
        validates.that("postCode", isNotBlank(), _else(report, "required", fieldName()));
    }
}

</pre></p><p class='commentary'>And now lets look at what we have to do with our <span class='domaincode'>Customer</span>.  The main thing to look out for is that the validation report in <span class='domaincode'>Customer</span> must extend the validation report in <span class='domaincode'>Address</span>. Then all you do is <span class='method'>validates.associated()</span> </p><p><pre class='code'>public class Customer implements Validatable&lt;Customer.ValidationReport&gt;{
    private String name;
    private String email;
    private Address address;

    public interface ValidationReport extends Address.ValidationReport {
        void isBlank(String fieldName);
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that("name", isNotBlank(), _else(report, "isBlank", fieldName()));
        validates.that("email", isNotBlank(), _else(report, "isBlank", fieldName()));
        validates.associated("address", report);
    }
}
</pre></p><p class='commentary'>The first two validation rules are for the fields on the <span class='domaincode'>Customer</span>, and the third line says "descend into the address instance and validate it too".  There may be futher <span class='method'>validates.associated()</span> calls in <span class='domaincode'>Address</span> if needed.  Just remember that the validation report of a domain class needs to extend all the validation reports of its children. </p>
<div class='section'>InheritValidationRulesFromSuperClass</div></pre></p><p class='commentary'>If you have got validation rules in a super class, you will also want to make sure they apply to sub classes. If you want to do this there is a few bits of garbage you need to do with the generics: <ul> <li>Your super class needs to be genericized on the validation report, guaranteeing that it is at least a sub class of its own validation report</li> <li>Your sub class needs to bind its validation report to the abstract class and it does not need to implement <span class='interface'>Validatable</span>.</li> </ul> Goodness - I find this stuff so hard to remember. <br/> <br/> Now you can call <span class='method'>super.buildValidation()</span> and ensure that the sub class validation report extends the super class validation report </p><p><pre class='code'>public static abstract class AbstractCustomer&lt;R extends AbstractCustomer.ValidationReport&gt; implements Validatable&lt;R&gt;{
    private String name;

    public interface ValidationReport {
        void isBlank(String fieldName);
    }

    public void buildValidation(ValidationSyntax validates,
                                R report) {
        validates.that("name",isNotBlank(), _else(report, "isBlank", fieldName()));
    }
}
</pre></p><p class='commentary'>And now the sub class... </p><p><pre class='code'>public class Customer extends AbstractCustomer&lt;Customer.ValidationReport&gt;{
    private String email;

    public interface ValidationReport extends AbstractCustomer.ValidationReport {
        void required(String fieldName);
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        super.buildValidation(validates, report);
        validates.that("name",isNotBlank(), _else(report, "isBlank", fieldName()));
    }
}
</pre></p><p class='commentary'>Notice that <span class='method'>buildValidation()</span> in the super class uses <span class='class'>R</span> as its type.  And that the sub class does not need to implement <span class='interface'>Validatable</span> because it binds its version of the validation report to the <span class='method'>buildValidation()</span> in the super class.  Phew! </p>
<div class='section'>MakingValidationRulesConditional</div></pre></p><p class='commentary'>Sometimes you only want certain validation rules to fire in certain cases.  For example, only validate address line 2 if address line 1 has a value.  Or only validate the address of a customer if the customer is active.  You can do this kind of thing by tacking an <span class='method'>on()</span> clause onto the end of your validation rule. </p><p><pre class='code'>public class Address implements Validatable&lt;Address.ValidationReport&gt;{
    private String addressLine1;
    private String addressLine2;

    public interface ValidationReport {
        void required(String fieldName);
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that("addressLine1", isNotBlank(), _else(report, "required", fieldName()));
        validates.that(
                "addressLine2",
                isNotBlank(),
                _else(report, "required", fieldName())
        ).on(condition("addressLine1", isNotBlank()));
    }
}
</pre></p><p class='commentary'><span class='method'>condition()</span> is available as a static method on <span class='class'>SyntaxSupport.Conditions</span>.  In this case we are supplying it a field name and a validation.  Only if this is true for the object being validated will the associated validation rule fire.  A few things to note: <ul> <li>If you omit the validation part, <span class='method'>TrueValidation.isTrue()</span> will be used instead.  So you can say <span class='method'>on(condition("isActive"))</span></li> <li>Zero arg methods can be used in place of field names.  So you can say <span class='method'>on(condition("isActive()"))</span></li> </ul> <br/> <br/> You can use the logical operators for validation rules like and and or and not in these conditions - see the section below on logical operators.  </p>
<div class='section'>LogicalOperationsForValidationRules</div></pre></p><p class='commentary'>Sometimes you may want to combine validations into a logical expression to state your intent. I am talking about <span class='method'>and()</span>, <span class='method'>or()</span>, <span class='method'>not()</span> and the like. These operators are available on <span class='class'>SyntaxSupport.ValidationLogic</span> and you can combine them to your hearts content. </p><p><pre class='code'>public class Customer implements Validatable&lt;Customer.ValidationReport&gt;{
    private String name;

    public interface ValidationReport {
        void somethingWrong();
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that(
                "name",
                and(isLongerThan(2), isShorterThan(10)),
                _else(report, "somethingWrong")); //same as isBetween()
    }
}
</pre></p><p class='commentary'>The same kind of thing goes for <span class='method'>or()</span> and <span class='method'>not()</span>.  </p>
<div class='section'>SelectingWhichValidationRulesToFireAtValidationTime</div></pre></p><p class='commentary'>Sometimes you want to fire a particular arrangement of validation rules based on conditions that are only known to the caller.  The <span class='method'>on()</span> clause lets you state conditions for validation rules that depend on the objects state.  But what if you want to exclude a particular validation rule because, say, the class doing the validation knows that a special offer is on today and a certain rule therefore does not apply. <br/> <br/> Well you can do this by tagging your validation rules, then excluding particular tags at validation time. A tag can be any old object by the way. </p><p><pre class='code'>public class Customer implements Validatable&lt;Customer.ValidationReport&gt;{
    private int creditAvailable;

    public interface ValidationReport {
        void insufficientCredit();
    }

    public void buildValidation(ValidationSyntax validates,
                                ValidationReport report) {
        validates.that(
                "creditAvailable",
                isGreaterThan(1000),
                _else(report, "insufficientCredit")
        ).tags("Due Diligence");
    }
}

public void demonstrateRemovingTags() {
    Customer customer = new Customer();
    Customer.ValidationReport report = null; //its only a demo
    DefaultValidationBuilder builder = new DefaultValidationBuilder();
    customer.buildValidation(builder, report);
    builder.removeTags("Due Diligence");
    builder.validate(customer);
}
</pre></p><p class='commentary'>And now, minus your due diligence,  you can have your very own credit crunch :-) </p>
<div class='section'>PuttingThingsTogetherToDefineYourOwnValidationCallbackNamingScheme</div></div id='main'>