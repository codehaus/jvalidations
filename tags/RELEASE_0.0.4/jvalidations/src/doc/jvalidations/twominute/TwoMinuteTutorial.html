<link rel="stylesheet" href="../style.css" type="text/css"><div id='main'><h2>TwoMinuteTutorial</h2><p class='commentary'>Lets say you have this domain object, a <span class='domaincode'>Customer</span> with a name and an email address: </p>
<p><pre class='code'>public class Customer {
    private final String name;
    private final String email;

    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }
}

</pre></p><p class='commentary'>And lets say you want to validate that <span class='domaincode'>name</span> is not blank.  The first step, which might not seem directly relevant now but keep reading and you'll soon see why, is to create an interface that defines a method that will be called in the event of validation failing. As a convention we call this the <span class='domaincode'>ValidationReport</span> and we make it an interface nested in the domain object. In our case we will have a single method that will be called in the case of name being blank i.e. validation failing: </p>
<p><pre class='code'>public class Customer {
    private final String name;
    private final String email;

    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public interface ValidationReport {
        void nameIsBlank();
    }
}

</pre></p><p class='commentary'>Declaring an interface like this is an abstract statement by your <span class='domaincode'>Customer</span> of what it requires of classes attempting to validate it.  It is saying, "if you want to validate me, you need to be able to handle callbacks where I tell you <span class='domaincode'>nameIsBlank()</span>".  The class doing the validation therefore needs to supply an implementation of this interface, and can do as it pleases when its told that <span class='domaincode'>nameIsBlank()</span>. This is the <a href="http://c2.com/cgi/wiki?DependencyInversionPrinciple">dependency inversion principle</a> and it makes for good designs :-). <br/> <br/> The next step is to make <span class='domaincode'>Customer</span> validatable.  We do this by making it implement <span class='interface'>Validatable</span>, which will require you to implement <span class='method'>buildValidation</span>. This interface is genericized on the validation report.  Code makes it clearer: </p>
<p><pre class='code'>public class Customer implements Validatable&lt;Customer.ValidationReport&gt; {
    private final String name;
    private final String email;

    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public interface ValidationReport {
        void nameIsBlank();
    }

    public void buildValidation(ValidationSyntax validates, ValidationReport report) {
        //Your validation rules will go here
    }
}

</pre></p><p class='commentary'>And now all we have to do is define our validation rule.  As you can see from the snippet above, we put our validation rules in the <span class='method'>buildValidation</span> method.  The first parameter is an instance of the JValidations interface <span class='interface'>ValidationSyntax</span>.  This interface provides an api for expressing your validation rules. Name the parameter <span class='param'>validates</span> if you can, because it helps with readability, as you will see later. <br/> <br/> The second parameter is an instance of your validation report interface.  Name it <span class='param'>report</span> if you can, because again, it helps with readability. <br/> <br/> The general form of a validation statement is <br/> <br/> <span class='code'>validates.that(field_name, validation_rule, else_clause)</span> <br/> <br/> <b>field_name</b> is a string naming the field of this class that must be validated. <br/> <br/> <b>validation_rule</b> is an instance of the JValidations interface <span class='interface'>Validation</span>.  You will find many implementations of this interface available as static methods on classes in the package <span class='package'>jvalidations.validations</span> - <span class='class'>BlankValidation</span> for example has the static method <span class='method'>isNotBlank()</span>. <br/> <br/> <b>else_clause</b> is an instance of the JValidations interface <span class='interface'>ElseClause</span>.  The <b>else_clause</b> states what to do if validation fails.  Generally the idea is to call a method on your validation report, so this clause will state what method to call on your validation report, and with what parameters. There is a static method <span class='method'>_else</span> on the JValidations class <span class='class'>SyntaxSupport</span> to help you build these else clauses, and we will go into it in more detail later, but for now lets see some code: </p><p><pre class='code'>public void buildValidation(ValidationSyntax validates, ValidationReport report) {
    validates.that("name", isNotBlank(), _else(report,"nameIsBlank"));
}

</pre></p><p class='commentary'><b>Note</b> that <span class='method'>isNotBlank()</span> and <span class='method'>_else()</span> have been statically imported for readability. <br/> <br/> So you can see that this <b>else_clause</b> is saying "call the method <span class='method'>nameIsBlank()</span> on the <b>report</b> instance with no parameters".  We will cover cases where we want to pass parameters to the <b>report</b> methods later on.  For now though, lets see what happens if we also want to validate that email is not blank. <br/> <br/> Our first decision is what validation report method to call in the event of validation failure.  We could add a method <span class='domaincode'>emailIsBlank</span>, but this is not a scalable solution as we increase the number of fields and the number of validation rules.  Better to define a single method for failed "not blank" validations, with the offending field named as a parameter.  Alright then, lets first rework the validation report interface: </p><p><pre class='code'>public interface ValidationReport {
    void isBlank(String fieldName);
}

</pre></p><p class='commentary'>And now lets rework our existing "not blank" validation rule for <span class='domaincode'>name</span>.  I said earlier that <span class='method'>SyntaxSupport._else()</span> supports parameters to the validation report methods.  It can take any number of <span class='interface'>ParameterLookupForCallbackMethod</span> instances, one for each parameter that the validation report method requires.  Again, there are static methods on <span class='class'>SyntaxSupport.Parameters</span> that create these instances for you, and one of them is <span class='method'>fieldName()</span>.  So now we can rework our existing validation rule: </p><p><pre class='code'>public void buildValidation(ValidationSyntax validates, ValidationReport report) {
    validates.that("name", isNotBlank(), _else(report,"isBlank", fieldName()));
}

</pre></p><p class='commentary'>And adding our <span class='domaincode'>email</span> validation is easy: </p><p><pre class='code'>public void buildValidation(ValidationSyntax validates, ValidationReport report) {
    validates.that("name", isNotBlank(), _else(report,"isBlank", fieldName()));
    validates.that("email", isNotBlank(), _else(report,"isBlank", fieldName()));
}

</pre></p><p class='commentary'>So thats how to make a <span class='domaincode'>Customer</span> validatable.  Now you probably want to know how to actually check if a given <span class='domaincode'>Customer</span> instance is valid.  Our first step therefore is to make an implementation of <span class='domaincode'>Customer.ValidationReport</span> that does something when told there is something invalid with the <span class='domaincode'>Customer</span>. </p><p><pre class='code'>public class PrintingValidationReport implements Customer.ValidationReport {
    public void isBlank(String fieldName){
        System.out.println(fieldName + " is blank");
    }
}

</pre></p><p class='commentary'>And now we have all the bits and pieces to make the validation check.  Instantiate your <span class='domaincode'>Customer</span> and validation report instances, and then pass them to <span class='method'>JValidations.validate()</span>. </p><p><pre class='code'>public void demonstrateValidation() {
    Customer customer = new Customer("Ernie","");
    Customer.ValidationReport report = new PrintingValidationReport();
    JValidations.validate(customer, report);
}

</pre></p><p class='commentary'>And if you call this method you will see "email is blank" printed to stdout. </p></div id='main'>